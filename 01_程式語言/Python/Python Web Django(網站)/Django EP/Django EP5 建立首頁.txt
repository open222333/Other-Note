------------------概覽------------------
在定義了模型並創建了一些可以使用的初始庫記錄之後，是時候編寫將這些信息呈現給用戶的代碼了。 我們要做的第一件事是確定我們要在頁面中顯示的信息，並定義用於返回這些資源的URL。 然後，我們將創建一個URL映射器，視圖和模板來顯示頁面。

下圖描述了主要數據流，以及處理HTTP請求和響應時所需的組件。 當我們已經實現了模型時，我們將創建的主要組件是：

URL映射器將支持的URL（以及URL中編碼的任何信息）轉發到適當的視圖功能。
查看函數可從模型中獲取所需的數據，創建顯示數據的HTML頁面，並將頁面返回給用戶以在瀏覽器中查看。
在視圖中呈現數據時要使用的模板。

頁面所需的URL是：

    catalog/ — 主頁/索引頁面。
    catalog/books/ — 所有書籍的清單。
    catalog/authors/ — 所有作者列表。
    catalog/book/<id> — 特定書的詳細信息視圖，其主鍵為 <id> (the default)。 因此，例如/catalog/book/3，作為添加的第三本書。
    catalog/author/<id> — 特定作者的詳細信息視圖，其主鍵字段名為<id>。 例如，為第11位作者添加了/catalog/author/11。
------------------指令------------------
------------------詳解------------------
創建索引頁面
位置：(locallibrary/urls.py)
語法：
    urlpatterns += [
        path('catalog/', include('catalog.urls')),
    ]
導入函數 django.urls.include()時，它都會在指定的結束字符處分割URL字符串，並將剩餘的子字符串發送到所包含的URLconf 模塊以進行進一步處理。

位置：(locallibrary/catalog/urls.py)
    urlpatterns = [
        path('', views.index, name='index'),
    ]
path()函數定義以下內容：
    URL模式，它是一個空字符串：''。
    如果檢測到URL模式，將調用一個視圖函數：views.index,  它是views.py文件中名為index() 的函數。

path()  函數還指定一個name參數，它是此特定URL映射的唯一標識符。您可以使用該名稱來“反向”映射器，即，動態創建指向映射器旨在處理的資源的URL。 例如，通過在模板中添加以下鏈接，我們可以使用name參數從任何其他頁面鏈接到我們的主頁：
    <a href="{% url 'index' %}">Home</a>.

View (function-based)
View是一個用來處理 HTTP 請求的函式，根據需求從資料庫取得資料，通過使用 HTML 模板呈現此數據來生成 HTML , 並且在一個 HTTP 回應中返回 HTML 來呈現給用戶。
注意該文件已經導入 render() 快捷功能已使用模板和數據生成HTML文件。
位置：(catalog/views.py)


Template
模板是一個文本文件，用於定義文件（例如HTML頁面）的結構或佈局，並使用佔位符表示實際內容。 Django會在您的應用程序名為'templates'的目錄中自動查找模板。 因此，例如，在我們剛剛添加的索引視圖中， render() 函數將有望能夠找到文件 /locallibrary/catalog/templates/index.html，如果找不到該文件，則會引發錯誤。 如果您保存以前的更改並返回瀏覽器，則可以看到此信息-訪問127.0.0.1:8000現在將為您提供一個相當直觀的錯誤消息"TemplateDoesNotExist at /catalog/"以及其他詳細信息。


Extending templates
索引模板的頭部和身體將需要標準的HTML標記，以及用於導航的部分（到我們尚未創建的站點中的其他頁面）以及用於顯示一些介紹性文本和我們的書籍數據的部分。 對於我們網站上的每個頁面，大部分文本（HTML和導航結構）都是相同的。 Django模板語言允許您聲明一個基本模板，然後擴展它，而不是強迫開發人員在每個頁面中都複製此"樣板" ，只需替換每個特定頁面上不同的部分即可。

例如，基本模板 base_generic.html 可能類似於以下文本。 如您所見，其中包含一些"通用" HTML以及標題，側邊欄和內容的部分，這些部分使用命名的block 和endblock 模板標記進行了標記（以粗體顯示）。 區塊可以為空，或包含將在默認情況下用於派生頁面的內容。

注意:模板tags 類似於可以在模板中使用的功能，可以在模板中循環使用列表，基於變量的值執行條件操作等。除了模板標記之外，模板語法還允許您引用模板變量（傳遞給 模板），並使用template filters，該過濾器可重新格式化變量（例如，將字符串設置為小寫）。

<!DOCTYPE html>
<html lang="en">
<head>
  {% block title %}<title>Local Library</title>{% endblock %}
</head>

<body>
  {% block sidebar %}<!-- insert default navigation text for every page -->{% endblock %}
  {% block content %}<!-- default content text (typically empty) -->{% endblock %}
</body>
</html>

當我們想為特定視圖定義模板時，我們首先指定基本模板（帶有extends 模板標籤-請參見下一個代碼清單）。 如果我們要在模板中替換任何節，則使用與基本模板中相同的block/endblock節來聲明這些節。

例如，下面的代碼片段顯示了我們如何使用extends 模板標籤並覆蓋content 區塊。 生成的最終HTML將具有基本模板中定義的所有HTML和結構（包括您在title 區塊中定義的默認內容），但是將新的content 區塊插入到默認模板中。

{% extends "base_generic.html" %}

{% block content %}
  <h1>Local Library Home</h1>
  <p>Welcome to LocalLibrary, a website developed by <em>Mozilla Developer Network</em>!</p>
{% endblock %}

The LocalLibrary base template
下面列出了我們計劃用於LocalLibrary 網站的基本模板。 如您所見，其中包含一些HTML以及 title, sidebar, 和 content。 我們有一個默認標題（我們可能想要更改）和一個默認側邊欄，其中帶有指向所有書籍和作者列表的鏈接（我們可能不想更改，但是如果需要的話，我們允許範圍通過將其放在 在一個區塊中）。

注意: 我們還引入了兩個附加的模板標籤：url 和load static。 這些將在以下各節中討論。

創建一個新文件/locallibrary/catalog/templates/base_generic.html ，並為其提供以下內容：

<!DOCTYPE html>
<html lang="en">
<head>
  {% block title %}<title>Local Library</title>{% endblock %}
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">

  <!-- Add additional CSS in static file -->
  {% load static %}
  <link rel="stylesheet" href="{% static 'css/styles.css' %}">
</head>
<body>
  <div class="container-fluid">
    <div class="row">
      <div class="col-sm-2">
      {% block sidebar %}
      <ul class="sidebar-nav">
        <li><a href="{% url 'index' %}">Home</a></li>
        <li><a href="">All books</a></li>
        <li><a href="">All authors</a></li>
      </ul>
     {% endblock %}
      </div>
      <div class="col-sm-10 ">
      {% block content %}{% endblock %}
      </div>
    </div>
  </div>
</body>
</html>
該模板包括來自Bootstrap的CSS，以改進HTML頁面的佈局和表示方式。 使用Bootstrap或其他客戶端Web框架是創建吸引人的頁面的快速方法，該頁面可以在不同的瀏覽器大小上很好地擴展。

基本模板還引用了本地CSS文件 (styles.css) ，該文件提供了一些其他樣式。 創建 /locallibrary/catalog/static/css/styles.css並為其提供以下內容：

.sidebar-nav {
    margin-top: 20px;
    padding: 0;
    list-style: none;
}

The index template
創建HTML文件 /locallibrary/catalog/templates/index.html 並為其提供以下內容。 如您所見，我們在第一行中擴展了基本模板，然後使用該模板的新內容塊替換默認content 區塊。

{% extends "base_generic.html" %}

{% block content %}
  <h1>Local Library Home</h1>
  <p>Welcome to LocalLibrary, a website developed by <em>Mozilla Developer Network</em>!</p>

  <h2>Dynamic content</h2>
  <p>The library has the following record counts:</p>
  <ul>
    <li><strong>Books:</strong> {{ num_books }}</li>
    <li><strong>Copies:</strong> {{ num_instances }}</li>
    <li><strong>Copies available:</strong> {{ num_instances_available }}</li>
    <li><strong>Authors:</strong> {{ num_authors }}</li>
  </ul>
{% endblock %}

注意：因為變量具有雙括號 ({{ num_books }})，而標籤則用百分號括在單括號中擴展為 ({% extends "base_generic.html" %})，所以您可以輕鬆識別是要處理模板變量還是模板標籤（函數）。

Referencing static files in templates
您的項目可能會使用靜態資源，包括JavaScript，CSS和圖像。 由於這些文件的位置可能未知（或可能會更改），因此Django允許您相對於STATIC_URL 全局設置在模板中指定這些文件的位置（默認框架網站將STATIC_URL 的值設置為'/static/'，但您可以選擇將其託管在內容分發網絡或其他地方）。

在模板中，您首先調用指定為“ static”的load 模板標籤以添加此模板庫（如下所示）。 加載靜態文件後，您可以使用static 模板標籤，指定感興趣文件的相對URL。

<!-- Add additional CSS in static file -->
{% load static %}
<link rel="stylesheet" href="{% static 'css/styles.css' %}">
如果需要，您可以以相同的方式將圖像添加到頁面中。 例如：

{% load static %}
<img src="{% static 'catalog/images/local_library_model_uml.png' %}" alt="UML diagram" style="width:555px;height:540px;">
注意：上面的更改指定了文件的位置，但是Django默認不提供文件。創建網站框架時 (created the website skeleton)，雖然我們在全局URL映射器(/locallibrary/locallibrary/urls.py)中啟用了由開發Web服務器提供的服務，但您仍需要安排它們在生產中提供。 我們待會再看。

有關使用靜態文件的更多信息，請參閱管理靜態文件https://docs.djangoproject.com/en/2.0/howto/static-files/ Managing static files (Django docs)。